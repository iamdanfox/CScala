/*

Copyright Â© 2007 - 2012 Bernard Sufrin, Worcester College, Oxford University

Licensed under the Artistic License, Version 2.0 (the "License"). 

You may not use this file except in compliance with the License. 

You may obtain a copy of the License at 

    http://www.opensource.org/licenses/artistic-license-2.0.php

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied. See the License for the specific
language governing permissions and limitations under the
License.

*/


package ox.cso

import java.net._

/**
    These utilities implement cso <code>Connection</code>s that
    transmit data to and from the network.  It is expected that 
    both connected peers will alternate outputs with inputs. 
    <p>
    We do not specify whether the client end peer or the server end
    peer does the first output to the connection.
    <p>
    The connections honour the extended rendezvous convention, in
    the sense that each output from a peer at one end of the
    connection is synchronised with the reception (at its end) of
    the response generated by the peer at the other end of the
    connection. <i>This constrains the degree of concurrency that
    can be achieved between peers</i>.    
    <p>
    In order to achieve a greater degree of concurrency the lower-level
    <code>NetIO</code> utilities should be used directly, with syn
    parameter <tt>false</tt>.
    
{{{
 @version 03.20120824
 @author Bernard Sufrin, Oxford
 $Revision: 470 $ 
 $Date: 2012-08-25 13:22:48 +0100 (Sat, 25 Aug 2012) $
}}}
*/
object SyncNetIO
{  import ox.CSO._
   type Serial = NetIO.Serial
   
   type Client[Req <: Serial, Rep <: Serial] = NetIO.Client[Req,Rep]
   type Server[Req <: Serial, Rep <: Serial] = NetIO.Server[Req,Rep]
  
  /** 
     Return a <code>Server[Req,Rep]</code> network connection to
     the server at the given host and port.
  */
  def clientConnection[Req <: Serial, Rep <: Serial]
                       (host: InetAddress, port: Int) : Server[Req, Rep] =
   { val server = NetIO.clientConnection[Req, Rep](host, port, true)
     val req = OneOne[Req]
     val rep = OneOne[Rep]
     ( proc ("SyncNetIO.clientConnection")
       { repeat
         { val reply = 
           req?( (request : Req) =>
                 { server ! request
                   server ? 
                 }
               )
           rep!reply
         }
         (proc {req.close} || proc {server.close} || proc {rep.close})()
       }
     ).fork
     new NetIO.Server(server.socket, req, rep)
   }
   
  /** 
     Return a <code>Server[Req,Rep]</code> network connection to
     the server at the given host and port.
  */
   def clientConnection[Req <: Serial, Rep <: Serial]
                       (host: String, port: Int) : Server[Req, Rep] =
       clientConnection(InetAddress.getByName(host), port)
          
   /**
      Transform the given <code>NetIO.Client</code> connection Into
      a synchronized <code>NetIO.Client</code> connection.
   */
   def serverConnection[Req <: Serial, Rep <: Serial]
                       (client: Client[Req,Rep]): Client[Req,Rep] =  
   {
     val req = OneOne[Req]
     val rep = OneOne[Rep]
     ( proc ("SyncNetIO.serverConnection")
       { repeat
         { client ? ( (param  : Req) => req    ! param  )
           rep    ? ( (result : Rep) => client ! result )
         }
         (proc {req.close} || proc {client.close} || proc {rep.close})()

       }
     ).fork
     new NetIO.Client(client.socket, req, rep)
   }
   
   /** 
       Set up a server at the given port with the specified backlog;
       each connection made to the server sends a synchronized
       <code>Client[Req,Rep]</code> network connection down
       <code>clients</code>.
   */   
   def serverPort[Req <: Serial, Rep <: Serial]
                 (port: Int, backlog: Int, clients: OutPort[Client[Req, Rep]]) : PROC =
       NetIO.serverPort(port, backlog, true,
                                (client: Client[Req, Rep]) => clients!serverConnection(client))
   
   /** 
       Set up a server at the given port with the default backlog;
       each connection made to the server sends a synchronized
       <code>Client[Req,Rep]</code> network connection down
       <code>clients</code>.
   */    
   def serverPort[Req <: Serial, Rep <: Serial]
                 (port: Int, clients: OutPort[Client[Req, Rep]]) : PROC =
       serverPort(port, 0, clients)
   
}







